package straightline;

import java_cup.runtime.*;
import java.util.List;
import java.util.LinkedList;
import java.util.Collections;

parser code  {: 

  private String errorMessage = "Unknown Error";

  @Override
  public void syntax_error(java_cup.runtime.Symbol token) {
    errorMessage = "Syntax error at line " + (token.left + 1) + 
   	    ", column " + (token.right + 1) + "."; 
  } 

  @Override
  public void unrecovered_syntax_error(Symbol cur_token) throws ParseException {
    report_fatal_error(errorMessage, cur_token);
  }

  @Override
  public void report_fatal_error(String message, Object info) throws ParseException {
    throw new ParseException(message); 
  } 
  
:};


/* Terminalsymbole, die vom Lexer produziert werden. */
terminal String IDENTIFIER;
terminal Integer INTEGER_LITERAL;
terminal BECOMES;
terminal PLUS;
terminal MINUS;
terminal TIMES;
terminal DIVIDE;
terminal COMMA;
terminal LPAREN;
terminal RPAREN;
terminal SEMICOLON;

terminal LSQUARE;
terminal RSQUARE;
terminal LCURLY;
terminal RCURLY;
terminal AND;
terminal LT;
terminal NOT;
terminal DOT;

terminal CLASS;
terminal PUBLIC;
terminal STATIC;
terminal VOID;
terminal MAIN;
terminal EXTENDS;
terminal RETURN;
terminal IF;
terminal ELSE;
terminal WHILE;
terminal THIS;
terminal NEW;

terminal TYPE_STRING;
terminal TYPE_INT;
terminal TYPE_BOOLEAN;
terminal TYPE_CHAR;

terminal SYSTEM_OUT_PRINTLN;
terminal SYSTEM_OUT_PRINT;
terminal ARRLEN;

terminal TRUE;
terminal FALSE;

// EOF is created automatically

/* Nichtterminalsymbole */
non terminal Goal;
non terminal MainClass;
non terminal ClassDeclaration;
non terminal ClassDeclarationList;
non terminal VarDeclaration;
non terminal VarDeclarationList;
non terminal MethodDeclaration;
non terminal MethodDeclarationList;
non terminal ParameterDeclarationListAndParens;
non terminal ParameterDeclarationList;
non terminal ParameterDeclaration;
non terminal StatementList;
non terminal Statement;
non terminal Expression;
non terminal ExpressionList;
non terminal AndExp;
non terminal LessThanExp;
non terminal AdditiveExp;
non terminal Term;
non terminal Factor;
non terminal NotExp;
non terminal PostfixExp;
non terminal PrimaryExp;
non terminal ArrayLookup;
non terminal ArrayLength;
non terminal NewIntArray;
non terminal NewInstance;
non terminal MethodInvocationOnInstance;
non terminal MethodInvocationParameterList;
non terminal Type;
non terminal Identifier;

/* Praezedenzregeln */
precedence nonassoc BECOMES;
precedence nonassoc AND;
precedence left LT;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;
precedence right NEW;
precedence right NOT;
precedence left DOT;

/* Startsymbol */
start with Goal;

/* Grammatik */
Goal ::=  MainClass:m ClassDeclarationList:c
          {: :};

MainClass ::=
    CLASS:c Identifier:name LCURLY PUBLIC STATIC VOID MAIN LPAREN TYPE_STRING LSQUARE RSQUARE Identifier:args RPAREN LCURLY Statement:stmt RCURLY RCURLY
    {: :}
;

ClassDeclaration ::=
    CLASS Identifier:i LCURLY VarDeclarationList:v MethodDeclarationList:m RCURLY
    {: :}
  |
    CLASS Identifier:i EXTENDS Identifier:parent LCURLY VarDeclarationList:v MethodDeclarationList:m RCURLY
    {: :}
;

ClassDeclarationList ::=
    {: :}
  |
    ClassDeclaration:c ClassDeclarationList:l
    {: :}
;

VarDeclarationList ::=
    {: :}
  |
    VarDeclarationList:l VarDeclaration:v
    {: :}
;

VarDeclaration ::=
    Type:t Identifier:i SEMICOLON
    {: :}
;

MethodDeclarationList ::=
    {: :}
  |
    MethodDeclaration:m MethodDeclarationList:l
    {: :}
;

MethodDeclaration ::=
    PUBLIC:p Type:t Identifier:i ParameterDeclarationListAndParens LCURLY VarDeclarationList:vars StatementList:stmts RETURN Expression:rv SEMICOLON RCURLY
    {: :}
;

ParameterDeclarationListAndParens ::=
    LPAREN:l RPAREN:r
    {: :}
  |
    LPAREN ParameterDeclarationList:params RPAREN
    {: :}
;

ParameterDeclarationList ::=
    ParameterDeclaration:p COMMA ParameterDeclarationList:l
    {: :}
  |
    ParameterDeclaration:p
    {: :}
;

ParameterDeclaration ::=
    Type:t Identifier:i
    {: :}
;

StatementList ::=
    {: :}
  |
    Statement:s StatementList:l
    {: :}
;

Statement   ::=
    Identifier:id BECOMES Expression:expr SEMICOLON
    {: :}
  |
    IF:ifKeyword LPAREN Expression:expr RPAREN Statement:thenStmt ELSE Statement:elseStmt
    {: :}
  |
    SYSTEM_OUT_PRINT:s LPAREN LPAREN TYPE_CHAR RPAREN Expression RPAREN SEMICOLON
    {: :}
  |
    SYSTEM_OUT_PRINTLN:s LPAREN Expression:e RPAREN SEMICOLON
    {: :}
  |
    Identifier:id LSQUARE Expression:e RSQUARE BECOMES Expression:v SEMICOLON
    {: :}
  |
    WHILE:w LPAREN Expression:cond RPAREN Statement:s
    {: :}
  |
    LCURLY StatementList:s RCURLY
    {: :}
;

Expression ::=
    AndExp:a
    {: :}
;

AndExp ::=
    LessThanExp:i AND AndExp:a
    {: :}
  |
    LessThanExp:i
    {: :}
;

LessThanExp ::=
    AdditiveExp LT AdditiveExp
    {: :}
  |
    AdditiveExp
    {: :}
;

AdditiveExp ::=
    Term:lhs PLUS AdditiveExp:rhs
    {: :}
  |
    Term:lhs MINUS AdditiveExp:rhs
    {: :}
  |
    Term:lhs
    {: :}
;

Term ::=
    Factor:lhs TIMES Term:rhs
    {: :}
  |
    Factor:lhs DIVIDE Term:rhs
    {: :}
  |
    Factor:lhs
    {: :}
;

Factor ::=
    NotExp:n
    {: :}
  |
    PostfixExp:p
    {: :}
;

NotExp ::=
    NOT PostfixExp:p
    {: :}
;

PostfixExp ::=
    ArrayLookup:i
    {: :}
  |
    ArrayLength:l
    {: :}
  |
    MethodInvocationOnInstance:m
    {: :}
  |
    PrimaryExp:p
;

PrimaryExp ::=
    INTEGER_LITERAL:i
    {: :}
  |
    TRUE:t
    {: :}
  |
    FALSE:f
    {: :}
  |
    Identifier:i
    {: :}
  |
    THIS:t
    {: :}
  |
    NewIntArray:a
    {: :}
  |
    NewInstance:o
    {: :}
  |
    LPAREN Expression:expr RPAREN
    {: :}
;

NewIntArray::=
    NEW:n TYPE_INT LSQUARE Expression:e RSQUARE
    {: :}
;

ArrayLength ::=
    PrimaryExp:e DOT ARRLEN
    {: :}
;

ArrayLookup ::=
    PrimaryExp:e LSQUARE Expression:i RSQUARE
    {: :}
;

NewInstance ::=
    NEW:n Identifier:i LPAREN RPAREN
    {: :}
;

MethodInvocationOnInstance ::=
    PrimaryExp:e DOT Identifier:id MethodInvocationParameterList:l
    {: :}
;

MethodInvocationParameterList ::=
    LPAREN:l RPAREN:r
    {: :}
  |
    LPAREN:l ExpressionList:e RPAREN
    {: :}
;

Type ::=
    TYPE_INT:i LSQUARE RSQUARE
    {: :}
  |
    TYPE_BOOLEAN:b
    {: :}
  |
    TYPE_INT:i
    {: :}
  |
    Identifier:i
    {: :}
;

ExpressionList ::=
    Expression:e
    {: :}
  | Expression:e COMMA ExpressionList:l
    {: :}
;

Identifier ::=
    IDENTIFIER:id
    {: :}
;
